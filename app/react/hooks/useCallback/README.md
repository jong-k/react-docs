# useCallback
> 리렌더링 간에 함수 정의를 캐싱

## 정리
매개변수
1. 캐싱(메모이제이션)할 함수
2. 의존성 배열: props, state, 이외의 모든 변수나 함수

반환값
- 캐싱된 함수
  - 최초 렌더링: 전달받은 함수를 그대로 반화
  - 리렌더링:
    - `의존성이 바뀌면`: 캐시 무효화하고 새 함수 반환
    - `의존성이 바뀌지 않으면`: 캐시된 함수 반환

### useCallback이 필요할 때
- `memo` 래핑된 컴포넌트에 props로 함수를 전달할 때, 함수를 캐싱하여 컴포넌트 리렌더링 줄일 수 있음
- 캐싱한 함수가 다른 Hook의 의존성으로 사용될 때
  - e.g. useEffect의 의존성으로 사용됨
- useCallback은 가독성을 해치기 때문에 필요한 경우에만 사용해야 함
- useCallback이 함수의 생성을 막지는 않음 (항상 새로 함수가 생성되기는 함)

### memoization을 사용하지 않아도 성능을 최적화하는 방법
- 부모 컴포넌트가 자식 컴포넌트를 래핑하고 있다면, JSX를 children props로 받게 할 것
  - 컴포넌트는 순수함수이므로 부모 컴포넌트가 상태를 업데이트해도, 자식 컴포넌트(JSX)가 변경이 없다면, 리렌더링이 발생하지 않음
- 가능한 로컬 상태를 사용하고 불필요한 props를 전달하지 말 것
- 렌더링 로직을 순수하게 유지할 것
  - 리렌더링 시 사이드 이펙트가 발생하면 안됨
- 상태를 업데이트하는 불필요한 effects 를 방지할 것
  - React 앱에서 대부분의 성능 문제는 effect로부터 발생하는 연속된 업데이트로 인한 리렌더링
- effect에서 불필요한 의존성 제거

### Effect가 너무 자주 실행되는 것을 방지하기
- 모든 반응형 값은 Effect의 의존성으로 선언되어야 한다
- 하지만 의존성 배열에 추가하면 Effect가 필요 이상으로 동작할 수 있다

이를 위해, Effect에서 호출하려는 함수를 useCallback으로 감쌀 수 있다
- 또는, memoization 대신에, Effect 내부에서 함수를 선언할 수도 있다

### 커스텀훅 최적화하기
- 반환하는 모든 함수를 useCallback으로 감싸는 것이 좋다
